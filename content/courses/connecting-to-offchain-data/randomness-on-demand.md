---
title: Verifiable Randomness with Randomness On-Demand
objectives:
  - Explain the limitations of generating random numbers onchain
  - Explain how Randomness On-Demand works
  - Use Switchboard's Randomness On-Demand Oracle queue to generate and consume randomness
description: "Use proper cryptographic randomness in your onchain programs."
---

## Summary

- Attempts at generating randomness within your program are likely to be
  guessable by users given there's no true randomness onchain.
- Randomness On-Demand allows developers to
  incorporate securely generated random numbers in their onchain programs.
- Switchboard offers developer-friendly Randomness On-Demand oracles for the Solana ecosystem.

## Lesson

### Randomness onchain

Random numbers are **_not_** natively allowed onchain. This is because Solana is
deterministic, every validator runs your code and needs to have the same result.
So if you wanted to create a raffle program, you'd have to look outside of the
blockchain for your randomness. This is where Switchboard's Randomness On-Demand
comes in. It offers developers a secure means of integrating randomness onchain
by utilizing Trusted Execution Environments (TEEs) and future slot hashes as entropy
sources.

### Types of Randomness

Before we dive into how random numbers can be generated for a blockchain, we
must first understand how they are generated on traditional computer systems.
There are two types of random numbers: _true random_ and _pseudorandom_.
The difference between the two lies in how the numbers are generated.

Computers can acquire _true random_ numbers by taking some type of physical
measurement of the outside world as entropy. These measurements use natural phenomena, such as electronic noise, radioactive decay, or
atmospheric noise, to generate random data. Because these processes are
intrinsically unpredictable, the numbers they produce are genuinely random and
not reproducible.

_Pseudorandom_ numbers, on the other hand, are generated by algorithms that use
a deterministic process to produce sequences of numbers that appear to be
random. Pseudorandom number generators (PRNGs) start with an initial value
called a seed and then use mathematical formulas to generate subsequent numbers
in the sequence. Given the same seed, a PRNG will always produce the same
sequence of numbers. It's important to seed with something close to true
entropy: an admin-provided "random" input, the last system log, some combination
of your system's clock time and other factors, etc. Fun fact: older video games
have been broken because speedrunners found out how their randomness was
calculated. One game used the number of steps you've taken in the
game as a seed.

Unfortunately, neither type of randomness is natively available in Solana
programs, because these programs have to be deterministic. All validators need
to come to the same conclusion. There is no way they'd all draw the same random
number, and if they used a seed, it'd be prone to attacks. See the
[Solana FAQs](https://solana.com/docs/programs/lang-rust#depending-on-rand) for
more. So we'll have to look outside of the blockchain for randomness with Randomness On-Demand services.

### What is Randomness On-Demand?

Randomness On-Demand is a method for generating verifiable and unpredictable random numbers on a blockchain. It utilizes a two-step process of commit and reveal, tied to specific blockchain slots. This approach aims to provide secure and fair randomness for various blockchain applications.

The system works by allowing users to request randomness based on a future slot's hash. This request is made to an oracle network, which then generates the random value when that future slot is reached. The process ensures that neither the user nor the oracle can predict or manipulate the outcome.

There are three key properties of Randomness On-Demand:

1. **Slot-based Seeding** - The system uses future slot hashes as a source of entropy. This ties the randomness generation to the blockchain's progression, making it harder to manipulate.

2. **Unpredictability** - Because the randomness is based on future slot hashes, it cannot be predicted at the time of request. This provides a strong guarantee of fairness in applications using this randomness.

3. **Verifiability** - The process of randomness generation can be verified by anyone observing the blockchain, ensuring transparency and trust in the system.

Randomness On-Demand systems are designed to address some of the challenges faced by traditional random number generation methods in blockchain environments, particularly in terms of security and fairness.

### Randomness On-Demand Implementation

Randomness On-Demand is typically implemented through a network of oracles. These oracles are services that provide external data to a blockchain, allowing them to interact with and respond to real-world events. In a Randomness On-Demand system, the Oracle network is responsible for processing randomness requests and delivering verifiable random numbers.

The process usually involves the following steps:

1. A user submits a request for randomness, specifying a future slot.
2. The oracle network commits to providing randomness based on that future slot's hash.
3. When the specified slot is reached, the oracle generates the random number.
4. The random number is then made available on-chain for the requesting application to use.

Randomness On-Demand is not specific to Solana and similar concepts have been utilized on other blockchains to
generate pseudorandom numbers. Fortunately, Switchboard offers their
implementation of Randomness On-Demand to Solana.

### Requesting and Consuming Randomness

Now that we understand how Randomness On-Demand works with the Switchboard Oracle network, let's explore how to request and consume randomness from a Solana program.
At a high level, the process for requesting and consuming randomness from Switchboard looks like this:

1. Create a `randomness` account that will be used to store the randomness request and result.
2. Commit to using a future slot's hash as the seed for randomness
3. Wait for the committed slot to arrive
4. Reveal the randomness using the committed slot hash
5. Consume the randomness by reading from the `randomness` account

Let's go through each step of the process in detail.

First, we need to create a `randomness` account. This account will be used to store the randomness request and result. Here's how you can create this account:

```bash
yarn add @switchboard-xyz/solana.js
```

```typescript
import { Randomness, getProgramId, getDefaultQueue, AnchorUtils, asV0Tx } from "@switchboard-xyz/on-demand";

const { connection, keypair, program: sbIdlprogram } = await AnchorUtils.loadEnv();

// Get switchboard program id and idl
const sbProgramId = await getProgramId(provider.connection);
const sbIdl = await anchor.Program.fetchIdl(sbProgramId, provider);
const sbProgram = new anchor.Program(sbIdl!, provider);

// setup queue
let queue = await setupQueue(sbIdlprogram!);

// Create Randomness account
const randomnessKeypair = anchor.web3.Keypair.generate();
const [randomness, createIx] = await Randomness.create(sbProgram, randomnessKeypair, queue);

// Create and send the transaction
const { connection, keypair, program: sbIdlprogram } = await AnchorUtils.loadEnv();

const createRandomnessTx = await asV0Tx({
    connection: sbProgram.provider.connection,
    ixs: [createIx],
    payer: keypair.publicKey,
    signers: [keypair, randomnessKeypair],
    computeUnitPrice: 75_000,
    computeUnitLimitMultiple: 1.3,
});

const sim = await connection.simulateTransaction(createRandomnessTx, txOpts);
const sig1 = await connection.sendTransaction(createRandomnessTx, txOpts);
await connection.confirmTransaction(sig1, COMMITMENT);

console.log(
    "  Transaction Signature for randomness account creation and requesting randomness: ",
    sig1
);
```

Queue is a Switchboard subnetwork, which maintains a list of oracles. To setup Queue, we can call this function:

```typescript

async function setupQueue(program: anchor.Program): Promise<PublicKey> {
    const queueAccount = await getDefaultQueue(
        program.provider.connection.rpcEndpoint
    );
    console.log("Queue account", queueAccount.pubkey.toString());
    try {
        await queueAccount.loadData();
    } catch (err) {
        console.error("Queue not found, ensure you are using devnet in your env");
        process.exit(1);
    }
    return queueAccount.pubkey;
}

```

Next, we need to commit to future randomness by calling the `commit` instruction on the Switchboard program.

```typescript
// Request randomness
const commitIx = await randomness.commitIx(queue);

//Send commit instruction in the same transaction
const commitRandomnessTx = await asV0Tx({
    connection: sbProgram.provider.connection,
    ixs: [commitIx],
    payer: keypair.publicKey,
    signers: [keypair],
    computeUnitPrice: 75_000,
    computeUnitLimitMultiple: 1.3,
});

const sim2 = await connection.simulateTransaction(commitAndRequestRandomnessTx, txOpts);
const sig2 = await connection.sendTransaction(commitAndRequestRandomnessTx, txOpts);
await connection.confirmTransaction(sig2, COMMITMENT);
```

Once the Switchboard program receives the `commit` request, it assigns an oracle to handle it. The oracle will wait until the specified slot is reached before generating the random value.

After the oracle has generated and submitted the random value, it can be revealed. Here's how you can read the randomness:

``` typescript
// reveal randomness instruction
const revealIx = await randomness.revealIx();

// reveal randomness instruction
const revealIx = await randomness.revealIx();

const revealRandomnessTx = await asV0Tx({
    connection: sbProgram.provider.connection,
    ixs: [revealIx],
    payer: keypair.publicKey,
    signers: [keypair],
    computeUnitPrice: 75_000,
    computeUnitLimitMultiple: 1.3,
});
```

Now you have randomness! Hooray!

That's the essence of requesting and consuming randomness with Switchboard's Randomness On-Demand.

Remember, you can use the resulting random value in various ways depending on your program's needs. The example of generating a dice roll is just one simple application.

## Lab

For this lesson’s lab, we will be picking up where we left off in the
[Oracle lesson](/content/courses/connecting-to-offchain-data/oracles). If you
haven't completed the Oracle lesson and demo, we strongly recommend you do as
there are a lot of overlapping concepts and we’ll be starting from the Oracle
lesson’s codebase.

If you don't want to complete the Oracle lesson, the starter code for this lab
is provided for you in
[the main branch of the lab Github repository](https://github.com/solana-developers/burry-escrow).

The repo contains a "Michael Burry" escrow program. This is a program that
allows a user to lock up some Solana funds in escrow that cannot be withdrawn
until SOL has reached a predefined price in USD chosen by the user. We will be
adding VRF functionality to this program to allow the user to "Get out of jail"
by rolling doubles. Our demo today will allow the user to roll two virtual dice,
if they roll doubles (the two dice match), the user can withdraw their funds
from escrow regardless of the SOL price.

#### 1. Program Setup

If you are cloning the repo from the previous lesson make sure to do the
following:

1. `git clone https://github.com/solana-developers/burry-escrow.git`
2. `cd michael-burry-escrow`
3. `anchor build`
4. `anchor keys list`
   1. Take the resulting key and put it into `Anchor.toml` and
      `programs/burry-escrow/src/lib.rs`
5. `solana config get`
   1. Take your **Keypair Path** and change the `wallet` field in your
      `Anchor.toml`
6. `yarn install`
7. `anchor test`

When all tests pass we’re ready to begin. We will start by filling in some
boilerplate stuff, then we’ll implement the functions.

#### 2. Cargo.toml

First, we need to add switchboard-on-demand crate and add 'init-if-needed' feature to anchor-lang.
This feature will be useful for working with randomness state account.

```typescript
[dependencies]
anchor-lang = {version="0.30.1", features = ["init-if-needed"]}
switchboard-on-demand = "0.1.14"
switchboard-solana = "0.30.4"
```

#### 3. Lib.rs

Next, let's edit `lib.rs` and add the additional functions we'll be building
today. The functions are as follows:

- `init_randomness_state` - Initializes randomness state
- `request_randomness` - Updates randomness state with randomness account which is committed for future randomness
- `get_out_of_jail` - Rolls the dice by checking revealed randomness

```rust
use anchor_lang::prelude::*;
use instructions::deposit::*;
use instructions::withdraw::*;
use instructions::init_randomness_state::*;
use instructions::get_out_of_jail::*;
use instructions::request_randomness::*;

pub mod errors;
pub mod instructions;
pub mod state;

declare_id!("YOUR_KEY_HERE");

#[program]
pub mod burry_escrow {
    use super::*;

    pub fn deposit(ctx: Context<Deposit>, escrow_amt: u64, unlock_price: f64) -> Result<()> {
        deposit_handler(ctx, escrow_amt, unlock_price)
    }

    pub fn withdraw(ctx: Context<Withdraw>) -> Result<()> {
        withdraw_handler(ctx)
    }

    pub fn get_out_of_jail(ctx: Context<GetOutOfJail>) -> Result<()>{
        get_out_of_jail_handler(ctx)
    }

    pub fn init_randomness_state(ctx: Context<InitRandomnessState>) -> Result<()> {
        init_randomness_state_handler(ctx)
    }

    pub fn request_randomness(ctx: Context<RequestRandomness>, randomness_account: Pubkey) -> Result<()> {
        request_randomness_handler(ctx, randomness_account)
    }
}

```

Make sure you replace `YOUR_KEY_HERE` with your program key.

#### 4. State.rs

Next, in `state.rs`, add an `out_of_jail` flag to `EscrowState`. When we finally
roll two matching die, we'll flip this flag. When the `withdraw` function is
called we can transfer the funds without checking the price.

```rust
// state.rs
#[account]
pub struct EscrowState {
    pub unlock_price: f64,
    pub escrow_amount: u64,
    pub out_of_jail: bool
}
```

Then, create our second data account for this program: `RandomnessState`. This
will hold the state of our dice rolls. It will have the following fields:

- `bump` - Stores the bump of the account for easy signing later.
- `randomness_account` - This is where the reveal function will dump the raw randomness
  data.
- `dice_type` - We will set this to 6 as in a 6-sided die.
- `die_result_1` and `die_result_2` - The results of our dice roll.
- `escrow` - Public key of our burry escrow account.

Lastly, we are going to add the `RANDOMNESS_SEED` to PDA our Randomness state account.

```rust
pub const RANDOMNESS_SEED: &[u8] = b"RANDOMNESS";
```

Your `state.rs` file should look like this:

```rust
use anchor_lang::prelude::*;

pub const ESCROW_SEED: &[u8] = b"MICHAEL BURRY";
pub const RANDOMNESS_SEED: &[u8] = b"RANDOMNESS";
pub const SOL_USDC_FEED: &str = "GvDMxPzN1sCj7L26YDK2HnMRXEQmQ2aemov8YBtPS7vR";

#[account]
pub struct EscrowState {
    pub unlock_price: f64,
    pub escrow_amount: u64,
    pub out_of_jail: bool,
}

#[account]
pub struct RandomnessState {
    pub bump: u8,
    pub randomness_account: Pubkey,
    pub dice_type: u8,
    pub die_result_1: u8,
    pub die_result_2: u8,
    pub escrow: Pubkey,
}
```

#### 5. Errors.rs

Next, let's take a quick pit stop and add two errors to `errors.rs`.
First is `RandomnessAlreadyRevealed` which we'll use when the randomness stored in the Randomness State account is already revealed.
The second is `RandomnessNotResolved`. We'll use this when randomness was not revealed before calling `get_out_of_jail` instruction.

```rust
use anchor_lang::prelude::*;

#[error_code]
#[derive(Eq, PartialEq)]
pub enum EscrowErrorCode {
    #[msg("Not a valid Switchboard account")]
    InvalidSwitchboardAccount,
    #[msg("Switchboard feed has not been updated in 5 minutes")]
    StaleFeed,
    #[msg("Switchboard feed exceeded provided confidence interval")]
    ConfidenceIntervalExceeded,
    #[msg("Current SOL price is not above Escrow unlock price.")]
    SolPriceAboveUnlockPrice,
    #[msg("Randomness has already been revealed")]
    RandomnessAlreadyRevealed,
    #[msg("Randomness has not been resolved yet")]
    RandomnessNotResolved,
}

```

#### 6. Mod.rs

Now, let's modify our `mod.rs` file to include the new functions we'll be
writing.

```rust
pub mod deposit;
pub mod withdraw;
pub mod init_randomness_state;
pub mod request_randomness;
pub mod get_out_of_jail;
```

#### 7. Deposit.rs and Withdraw.rs

Lastly, let's update our `deposit.rs` and `withdraw.rs` files to reflect our
soon-to-be new powers.

First, let’s initialize our `out_of_jail` flag to `false` in `deposit.rs`.

```rust
// in deposit.rs
...
let escrow_state = &mut ctx.accounts.escrow_account;
    escrow_state.unlock_price = unlock_price;
    escrow_state.escrow_amount = escrow_amount;
    escrow_state.out_of_jail = false;
...
```

Next, let's write our simple get-out-of-jail logic. Wrap our Oracle price-checks
with an `if` statement. If the `out_of_jail` flag on the `escrow_state` account
is false, then we check the price at which to unlock the SOL:

```rust
if !escrow_state.out_of_jail {
      // get result
      let val: f64 = feed.get_result()?.try_into()?;

      // check whether the feed has been updated in the last 300 seconds
      feed.check_staleness(Clock::get().unwrap().unix_timestamp, 300)
      .map_err(|_| error!(EscrowErrorCode::StaleFeed))?;

      msg!("Current feed result is {}!", val);
      msg!("Unlock price is {}", escrow_state.unlock_price);

      if val < escrow_state.unlock_price as f64 {
          return Err(EscrowErrorCode::SolPriceAboveUnlockPrice.into())
      }
  }
```

If `out_of_jail` is true, then we get out of jail free and can skip the price
check, going straight to our withdrawal.

#### 8. Using on-demand randomness.

Now that we have the boilerplate out of the way, let's move on to our first
addition: initializing an account for storing randomness state via the `init_randomness_state` instruction.

```rust
use crate::state::*;
use anchor_lang::prelude::*;

#[derive(Accounts)]
pub struct InitRandomnessState<'info> {
    #[account(mut)]
    pub user: Signer<'info>,
    #[account(
        mut,
        seeds = [ESCROW_SEED, user.key().as_ref()],
        bump,
    )]
    pub escrow_account: Account<'info, EscrowState>,
    #[account(
        init,
        payer = user,
        space = 8 + std::mem::size_of::<RandomnessState>(),
        seeds = [RANDOMNESS_SEED, user.key().as_ref()],
        bump
    )]
    pub randomness_state: Account<'info, RandomnessState>,
    pub system_program: Program<'info, System>,
}

pub fn init_randomness_state_handler(ctx: Context<InitRandomnessState>) -> Result<()> {
    let randomness_state = &mut ctx.accounts.randomness_state;
    randomness_state.dice_type = 6; // Set the dice type to 6-sided dice
    randomness_state.die_result_1 = 0; // Initialize dice results
    randomness_state.die_result_2 = 0;
    randomness_state.escrow = ctx.accounts.escrow_account.key();
    randomness_state.randomness_account = Pubkey::default(); // Will be set later during request_randomness
    Ok(())
}
```

Next, we'll add a `request_randomness` instruction to save the `randomness_account` to the randomness state. This account will be updated with the randomness data after the randomness is revealed.
Inside this instruction, we'll also check if the randomness has already been revealed or not by checking the `seed_slot` in the `randomness_account`.


``` rust
use crate::state::*;
use crate::errors::*;
use anchor_lang::prelude::*;
use switchboard_on_demand::RandomnessAccountData;

pub fn request_randomness_handler(ctx: Context<RequestRandomness>, randomness_account: Pubkey) -> Result<()> {
    let clock = Clock::get()?;

    // Parse the randomness account data
    let randomness_data = RandomnessAccountData::parse(ctx.accounts.randomness_account.data.borrow()).unwrap();

    // Check if the randomness has already been revealed
    if randomness_data.seed_slot != clock.slot - 1 {
        msg!("seed_slot: {}", randomness_data.seed_slot);
        msg!("slot: {}", clock.slot);
        return Err(EscrowErrorCode::RandomnessAlreadyRevealed.into());
    }

    // Update the RandomnessState
    let randomness_state = &mut ctx.accounts.randomness_state;
    randomness_state.randomness_account = randomness_account;

    Ok(())
}

#[derive(Accounts)]
pub struct RequestRandomness<'info> {
    #[account(mut)]
    pub user: Signer<'info>,
    #[account(
        init_if_needed,
        payer = user,
        space = 8 + std::mem::size_of::<RandomnessState>(),
        seeds = [RANDOMNESS_SEED, user.key().as_ref()],
        bump
    )]
    pub randomness_state: Account<'info, RandomnessState>,
    /// CHECK: This account is validated by Switchboard's on-demand randomness program
    pub randomness_account: AccountInfo<'info>,
    pub system_program: Program<'info, System>,
}

```

#### 9. Get Out of Jail

Now that we have the `RandomnessState` account initialized, we can use it in the
`get_out_jail` instruction. Create a new file called `get_out_of_jail.rs` in the
`/instructions` folder.

The `get_out_jail` instruction will check if the randomness has been revealed by Switchboard oracle and if doubles were rolled.
We'll need to pass in all of the accounts needed for both getting revealed randomness value and our
business logic.

Business Logic Accounts:

- `user` - The user account who has escrowed the funds.
- `escrow_account` - The burry escrow state account for the user.
- `randomness_state` - randomness state account that holds the dice results and references to `randomness_account` and `escrow_account`

Randomness Account:

- `randomness_account` - an account that holds the randomness data.

Here's the code for the `GetOutOfJail` struct defining these accounts:

```rust
#[derive(Accounts)]
pub struct GetOutOfJail<'info> {
    #[account(mut)]
    pub user: Signer<'info>,
    #[account(
        mut,
        seeds = [ESCROW_SEED, user.key().as_ref()],
        bump,
    )]
    pub escrow_account: Account<'info, EscrowState>,
    #[account(
        mut,
        seeds = [RANDOMNESS_SEED, user.key().as_ref()],
        bump,
    )]
    pub randomness_state: Account<'info, RandomnessState>,
    /// CHECK: This account is validated by Switchboard's on-demand randomness program
    pub randomness_account: AccountInfo<'info>,
}
```

Now, let's look at how we reveal and use the randomness:

```rust
pub fn get_out_of_jail_handler(ctx: Context<GetOutOfJail>) -> Result<()> {
    let clock = Clock::get()?;

    // Parse the randomness account data
    let randomness_data = RandomnessAccountData::parse(ctx.accounts.randomness_account.data.borrow()).unwrap();

    // Get the revealed random value
    let revealed_random_value = randomness_data.get_value(&clock)
        .map_err(|_| error!(EscrowErrorCode::RandomnessNotResolved))?;

}
```

This code parses the randomness account data and retrieves the revealed random value. If the randomness hasn't been resolved yet, it will return an error.

Next, we'll use this randomness to simulate rolling two dice:

```rust
    // Update the RandomnessState
    let randomness_state = &mut ctx.accounts.randomness_state;
    let dice_type = randomness_state.dice_type;

    randomness_state.die_result_1 = (revealed_random_value[0] % dice_type) + 1;
    randomness_state.die_result_2 = (revealed_random_value[1] % dice_type) + 1;
```

Since we only use two dice we only need the first two bytes of the obtained randomness value. To convert these random values into
"dice rolls", we use modular arithmetic. For anyone not familiar with modular
arithmetic,
[Wikipedia can help](https://en.wikipedia.org/wiki/Modular_arithmetic). In
modular arithmetic, numbers "wrap around" upon reaching a given fixed quantity.
This given quantity is known as the modulus to leave as the remainder. Here, the
modulus is the `dice_type` stored on the `randomness_state` account. We hard-coded this
to 6 when the account was initialized to represent a 6-sided die. When we use
`dice_type`, or 6, as the modulus, our result will be a number 0-5. We then add
one, to make the resulting possibilities 1-6.

> Fun fact from Christian (one of the editors): one byte per roll is actually a
> slightly bad option for a dice roll. (Good enough to demo) You have 256
> options in a u8. When modulo'd by 6, the number zero has a slight advantage in
> the distribution (256 is not divisible by 6). Number of 0s: (255-0)/6 + 1 = 43
> Number of 1s: (256-1)/6 = 42.6, so 42 occurrences of 1 Number of 2s: (257-2)/6
> = 42.5, so 42 occurrences of 2 Number of 3s: (258-3)/6 = 42.5, so 42
> occurrences of 3 Number of 4s: (259-4)/6 = 42.5, so 42 occurrences of 4 Number
> of 5s: (260-5)/6 = 42.5, so 42 occurrences of 5

Finally, we check if doubles were rolled and update the `out_of_jail` flag accordingly:

```rust
    // Check if doubles were rolled
    if randomness_state.die_result_1 == randomness_state.die_result_2 {
        // Update the EscrowState
        let escrow_state = &mut ctx.accounts.escrow_account;
        escrow_state.out_of_jail = true;
    }

    msg!("Dice roll results: {} and {}", randomness_state.die_result_1, randomness_state.die_result_2);

    Ok(())
```

If the `out_of_jail` becomes true, the user can then call the `withdraw`
instruction and it will skip over the price check.

Here's the complete `get_out_of_jail_handler` function:

```rust
use crate::state::*;
use crate::errors::*;
use anchor_lang::prelude::*;
use switchboard_on_demand::RandomnessAccountData;

pub fn get_out_of_jail_handler(ctx: Context<GetOutOfJail>) -> Result<()> {
    let clock = Clock::get()?;

    // Parse the randomness account data
    let randomness_data = RandomnessAccountData::parse(ctx.accounts.randomness_account.data.borrow()).unwrap();

    // Get the revealed random value
    let revealed_random_value = randomness_data.get_value(&clock)
        .map_err(|_| error!(EscrowErrorCode::RandomnessNotResolved))?;

    // Update the RandomnessState
    let randomness_state = &mut ctx.accounts.randomness_state;
    let dice_type = randomness_state.dice_type;

    randomness_state.die_result_1 = (revealed_random_value[0] % dice_type) + 1;
    randomness_state.die_result_2 = (revealed_random_value[1] % dice_type) + 1;

    // Check if doubles were rolled
    if randomness_state.die_result_1 == randomness_state.die_result_2 {
        // Update the EscrowState
        let escrow_state = &mut ctx.accounts.escrow_account;
        escrow_state.out_of_jail = true;
    }

    msg!("Dice roll results: {} and {}", randomness_state.die_result_1, randomness_state.die_result_2);

    Ok(())
}
```

And that's it for the get-out-of-jail functionality! Congrats, you have just
built a program that can consume Switchboard data feeds and submit VRF requests.
Please make sure your program builds successfully by running `anchor build`.

#### 11. Testing

Alright, let’s test our program. Create a new test file called `randomness-on-demand-test.ts` and copy and paste the code
below. It copies over the last two tests from the oracle lesson, adds some
imports, and adds a new function called `delay`.

```typescript
describe("burry-escrow-randomness", () => {
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.AnchorProvider.env());
  const provider = anchor.AnchorProvider.env()
  const program = anchor.workspace.BurryEscrow as Program<BurryEscrow>;
  const payer = (provider.wallet as AnchorWallet).payer;

  it("Create Burry Escrow Above Price", async () => {
    // fetch switchboard devnet program object
    const switchboardProgram = await SwitchboardProgram.load(
      new anchor.web3.Connection("https://api.devnet.solana.com"),
      payer,
    );
    const aggregatorAccount = new AggregatorAccount(
      switchboardProgram,
      solUSDSwitchboardFeed,
    );

    // derive escrow state account
    const [escrowState] = await anchor.web3.PublicKey.findProgramAddressSync(
      [Buffer.from("MICHAEL BURRY"), payer.publicKey.toBuffer()],
      program.programId,
    );
    console.log("Escrow Account: ", escrowState.toBase58());

    // fetch latest SOL price
    const solPrice: Big | null = await aggregatorAccount.fetchLatestValue();
    if (solPrice === null) {
      throw new Error("Aggregator holds no value");
    }
    const failUnlockPrice = solPrice.plus(10).toNumber();
    const amountToLockUp = new anchor.BN(100);

    // Send transaction
    try {
      const tx = await program.methods
        .deposit(amountToLockUp, failUnlockPrice)
        .accounts({
          user: payer.publicKey,
          escrowAccount: escrowState,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([payer])
        .rpc();

      await provider.connection.confirmTransaction(tx, "confirmed");
      console.log("Your transaction signature", tx);

      // Fetch the created account
      const newAccount = await program.account.escrowState.fetch(escrowState);

      const escrowBalance = await provider.connection.getBalance(
        escrowState,
        "confirmed",
      );
      console.log("Onchain unlock price:", newAccount.unlockPrice);
      console.log("Amount in escrow:", escrowBalance);

      // Check whether the data onchain is equal to local 'data'
      assert(failUnlockPrice == newAccount.unlockPrice);
      assert(escrowBalance > 0);
    } catch (e) {
      console.log(e);
      assert.fail(e);
    }
  });

  it("Attempt to withdraw while price is below UnlockPrice", async () => {
    let didFail = false;

    // derive escrow address
    const [escrowState] = await anchor.web3.PublicKey.findProgramAddressSync(
      [Buffer.from("MICHAEL BURRY"), payer.publicKey.toBuffer()],
      program.programId,
    );

    // send tx
    try {
      const tx = await program.methods
        .withdraw()
        .accounts({
          user: payer.publicKey,
          escrowAccount: escrowState,
          feedAggregator: solUSDSwitchboardFeed,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([payer])
        .rpc();

      await provider.connection.confirmTransaction(tx, "confirmed");
      console.log("Your transaction signature", tx);
    } catch (e) {
      // verify tx returns expected error
      didFail = true;
      console.log(e.error.errorMessage);
      assert(
        e.error.errorMessage ==
        "Current SOL price is not above Escrow unlock price.",
      );
    }

    assert(didFail);
  });
});
```

<Callout type="note">
If you only want to run the vrf tests, change
`describe("burry-escrow-randomness", () => {` to:
`describe.only("burry-escrow-randomness", () => {`
</Callout>

Now let's run the actual test. We'll structure the test to keep rolling dice
until we get doubles, then we'll check that we can withdraw the funds.

```typescript
it("Roll till you can withdraw", async () => {
   const { connection, keypair, program: sbIdlprogram } = await AnchorUtils.loadEnv();

   // derive escrow address
   const [escrowState] = await anchor.web3.PublicKey.findProgramAddressSync(
     [Buffer.from(ESCROW_SEED), payer.publicKey.toBuffer()],
     program.programId
   );

   // derive RandomnessState PDA
   const [randomnessState] = await anchor.web3.PublicKey.findProgramAddressSync(
     [Buffer.from(RANDOMNESS_SEED), payer.publicKey.toBuffer()],
     program.programId
   );

   console.log("randomnessState: ", randomnessState.toBase58());

   // Get switchboard program id
   const sbProgramId = await getProgramId(provider.connection);
   const sbIdl = await anchor.Program.fetchIdl(sbProgramId, provider);
   const sbProgram = new anchor.Program(sbIdl!, provider);

   console.log("Switchboard program id", sbProgramId.toString());

   // setup queue
   let queue = await setupQueue(sbIdlprogram!);

   // Create Randomness account
   const randomnessKeypair = anchor.web3.Keypair.generate();
   const [randomness, createIx] = await Randomness.create(sbProgram, randomnessKeypair, queue);

   console.log("\nCreated randomness account..");
   console.log("Randomness account", randomness.pubkey.toString());

   const txOpts = {
     commitment: "processed" as Commitment,
     skipPreflight: false,
     maxRetries: 0,
   };

   const createRandomnessTx = await asV0Tx({
     connection: sbProgram.provider.connection,
     ixs: [createIx],
     payer: keypair.publicKey,
     signers: [keypair, randomnessKeypair],
     computeUnitPrice: 75_000,
     computeUnitLimitMultiple: 1.3,
   });

   const sim = await connection.simulateTransaction(createRandomnessTx, txOpts);
   const sig1 = await connection.sendTransaction(createRandomnessTx, txOpts);
   await connection.confirmTransaction(sig1, COMMITMENT);

   console.log(
     "  Transaction Signature for randomness account creation and requesting randomness: ",
     sig1
   );

  // Initialize randomness state account
  await program.methods.initRandomnessState()
    .accounts({
        user: payer.publicKey,
        escrowAccount: escrowState,
        randomnessState: randomnessState,
        systemProgram: anchor.web3.SystemProgram.programId,
    })
    .signers([payer])
    .rpc();

  console.log("RandomnessState initialized");

   async function requestRandomnessAndTryToGetOutOfJail() {

     //Commit to randomness Ix
     console.log("\nCommit to randomness...");
     const commitIx = await randomness.commitIx(queue);

     // Create the requestRandomness instruction
     const requestRandomnessIx = await program.methods.requestRandomness(randomnessKeypair.publicKey)
       .accounts({
         user: payer.publicKey,
         escrowAccount: escrowState,
         randomnessState: randomnessState,
         randomnessAccount: randomnessKeypair.publicKey,
         systemProgram: anchor.web3.SystemProgram.programId,
       })
       .instruction();

     const commitAndRequestRandomnessTx = await asV0Tx({
       connection: sbProgram.provider.connection,
       ixs: [commitIx, requestRandomnessIx],
       payer: keypair.publicKey,
       signers: [keypair, payer],
       computeUnitPrice: 75_000,
       computeUnitLimitMultiple: 1.3,
     });

     const sim2 = await connection.simulateTransaction(commitAndRequestRandomnessTx, txOpts);
     const sig2 = await connection.sendTransaction(commitAndRequestRandomnessTx, txOpts);
     await connection.confirmTransaction(sig2, COMMITMENT);

     // Wait for the committed slot to pass
     await delay(5000);

     // reveal randomness instruction
     const revealIx = await randomness.revealIx();

     // Reveal randomness
     const getOutOfJailIx = await program.methods.getOutOfJail()
       .accounts({
         user: payer.publicKey,
         escrowAccount: escrowState,
         randomnessState: randomnessState,
         randomnessAccount: randomnessKeypair.publicKey,
       }).instruction();

     const revealRandomnessAndGetOutOfJailTx = await asV0Tx({
       connection: sbProgram.provider.connection,
       ixs: [revealIx, getOutOfJailIx],
       payer: keypair.publicKey,
       signers: [keypair, payer],
       computeUnitPrice: 75_000,
       computeUnitLimitMultiple: 1.3,
     });

     const sim3 = await connection.simulateTransaction(revealRandomnessAndGetOutOfJailTx, txOpts);
     const sig3 = await connection.sendTransaction(revealRandomnessAndGetOutOfJailTx, txOpts);
     await connection.confirmTransaction(sig3, COMMITMENT);

     console.log('Get out of jail transaction signature:', sig3);
   }

   let rolledDoubles = false;
   while (!rolledDoubles) {
     try {
       // Request randomness
       await requestRandomnessAndTryToGetOutOfJail();

       // Check dice roll results

       const randomnessStateAccount = await program.account.randomnessState.fetch(randomnessState);
       console.log("Die 1:", randomnessStateAccount.dieResult1);
       console.log("Die 2:", randomnessStateAccount.dieResult2);

       if (randomnessStateAccount.dieResult1 === randomnessStateAccount.dieResult2) {
         rolledDoubles = true;
         console.log("Rolled doubles!");
       } else {
         console.log("No doubles. Trying again...");
         await delay(5000);
       }

     } catch (e) {
       console.log(e);
       assert.fail(e);
     }
   }

   // Attempt to withdraw
   try {
     const tx = await program.methods.withdraw()
       .accounts({
         user: payer.publicKey,
         escrowAccount: escrowState,
         feedAggregator: solUSDSwitchboardFeed,
         systemProgram: anchor.web3.SystemProgram.programId,
       })
       .signers([payer])
       .rpc();

     await provider.connection.confirmTransaction(tx, "confirmed");
     console.log("Withdrawal successful");
   } catch (e) {
     console.log(e);
     assert.fail("Withdrawal should have succeeded after rolling doubles");
   }


 });
```

And there you have it! You should be able to run and pass all of the tests using
`anchor test`.

If something is not working, go back and find where you went wrong.
Alternatively, feel free to try out the
[solution code on the `vrf` branch](https://github.com/kmadorin/burry-escrow/tree/randomness-on-demand).
Remember to update your program keys and wallet path like we did in the
[the Setup step](#1-program-setup).

## Challenge

Now it's time to work on something independently. Let's add some
[Monopoly rules](<https://en.wikipedia.org/wiki/Monopoly_(game)#Rules>) to our
program. Add some logic to the program to track how many times a user rolls. If
they roll 3 times without rolling doubles, they should be able to withdraw their
funds, just like getting out of jail in Monopoly.

If you get stuck, we have the solution in the
[`randomness-on-demand-challenge-solution` branch](https://github.com/kmadorin/burry-escrow/tree/randomness-on-demand-challenge-solution).

<Callout type="success" title="Completed the lab?">
Push your code to GitHub and
[tell us what you thought of this lesson](https://form.typeform.com/to/IPH0UGz7#answers-lesson=5af49eda-f3e7-407d-8cd7-78d0653ee17c)!
</Callout>
